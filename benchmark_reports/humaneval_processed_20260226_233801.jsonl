{"problem_id": "HumanEval/0", "attempt": 1, "sanitized_code": "    n = len(numbers)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False\n", "entry_point_expected": "has_close_elements", "has_def_line": false, "body_line_count": 6, "is_stub": false, "timestamp": "2026-02-26T23:39:36.474225"}
{"problem_id": "HumanEval/1", "attempt": 1, "sanitized_code": "    import string\n    paren_string = paren_string.replace(\" \", \"\")  # Remove spaces\n    result = []\n    balance = 0\n    current_group = []\n\n    for char in paren_string:\n        if char == '(':\n            if balance == 0 and current_group:\n                result.append(''.join(current_group))\n                current_group = []\n            current_group.append(char)\n            balance += 1\n        elif char == ')':\n            current_group.append(char)\n            balance -= 1\n\n            if balance == 0:\n                result.append(''.join(current_group))\n                current_group = []\n\n    return result if balance == 0 else []\n\n    # Corrected test cases\n    print(separate_paren_groups('(()()) ((())) () ((())()())'))  # ['(()())', '((()))', '()', '((())()())']\n    print(separate_paren_groups(' (((()))) (((()))) '))          # ['((()))', '((()))']\n    print(separate_paren_groups('(()(())((())))'))                # ['(()(())((())))']\n    print(separate_paren_groups('() ((())) (()(()))'))            # ['()', '((()))', '(()(()))']\n    This improved response addresses the issues in separating valid groups and ensures clarity in the explanation and expectations around test cases\n", "entry_point_expected": "separate_paren_groups", "has_def_line": false, "body_line_count": 25, "is_stub": false, "timestamp": "2026-02-26T23:41:05.842039"}
{"problem_id": "HumanEval/2", "attempt": 1, "sanitized_code": "    integer_part = int(number)  # Get the integer part\n    decimal_part = number - integer_part  # Calculate the decimal part\n    return decimal_part\n", "entry_point_expected": "truncate_number", "has_def_line": false, "body_line_count": 3, "is_stub": false, "timestamp": "2026-02-26T23:46:05.273668"}
{"problem_id": "HumanEval/3", "attempt": 1, "sanitized_code": "    balance = 0\n    for operation in operations:\n        balance += operation\n        if balance < 0:\n            return True\n    return False\n", "entry_point_expected": "below_zero", "has_def_line": false, "body_line_count": 6, "is_stub": false, "timestamp": "2026-02-26T23:46:54.250802"}
{"problem_id": "HumanEval/4", "attempt": 1, "sanitized_code": "    if not numbers:\n        return 0.0\n\n    mean_value = sum(numbers) / len(numbers)\n    mad = sum(abs(x - mean_value) for x in numbers) / len(numbers)\n\n    return mad\n", "entry_point_expected": "mean_absolute_deviation", "has_def_line": false, "body_line_count": 5, "is_stub": false, "timestamp": "2026-02-26T23:47:59.503504"}
{"problem_id": "HumanEval/5", "attempt": 1, "sanitized_code": "    if not numbers:  # Handle empty list case\n        return []\n    result = []\n    for i in range(len(numbers) - 1):\n        result.append(numbers[i])\n        result.append(delimeter)  # Insert delimeter between elements\n    result.append(numbers[-1])  # Append the last element\n    return result\n", "entry_point_expected": "intersperse", "has_def_line": false, "body_line_count": 8, "is_stub": false, "timestamp": "2026-02-26T23:48:52.666890"}
{"problem_id": "HumanEval/6", "attempt": 1, "sanitized_code": "    import string\n    def parse_nested_parens(group: str) -> int:\n        depth = 0\n        parse_nested_parens = 0\n        for char in group:\n            if char == '(':\n                depth += 1\n                parse_nested_parens = max(parse_nested_parens, depth)\n            elif char == ')':\n                depth -= 1\n        return parse_nested_parens\n\n    groups = paren_string.split()\n    return [parse_nested_parens(group) for group in groups]\n", "entry_point_expected": "parse_nested_parens", "has_def_line": true, "body_line_count": 13, "is_stub": false, "timestamp": "2026-02-26T23:49:52.367076"}
{"problem_id": "HumanEval/7", "attempt": 1, "sanitized_code": "    return [s for s in strings if substring in s]\n", "entry_point_expected": "filter_by_substring", "has_def_line": false, "body_line_count": 1, "is_stub": false, "timestamp": "2026-02-26T23:50:45.893432"}
{"problem_id": "HumanEval/8", "attempt": 1, "sanitized_code": "    if not numbers:\n        return (0, 1)\n\n    total_sum = sum(numbers)\n    total_product = 1\n    for number in numbers:\n        total_product *= number\n\n    return (total_sum, total_product)\n", "entry_point_expected": "sum_product", "has_def_line": false, "body_line_count": 7, "is_stub": false, "timestamp": "2026-02-26T23:51:36.637584"}
{"problem_id": "HumanEval/9", "attempt": 1, "sanitized_code": "    if not numbers:\n        return []\n\n    max_so_far = numbers[0]\n    result = [max_so_far]\n\n    for number in numbers[1:]:\n        max_so_far = max(max_so_far, number)\n        result.append(max_so_far)\n\n    return result\n", "entry_point_expected": "rolling_max", "has_def_line": false, "body_line_count": 8, "is_stub": false, "timestamp": "2026-02-26T23:52:27.225105"}
{"problem_id": "HumanEval/10", "attempt": 1, "sanitized_code": "    if not string:\n        return ''\n\n    # Reverse the string for comparison\n    rev_string = string[::-1]\n\n    # Find the longest palindromic suffix\n    for i in range(len(string)):\n        if string[i:] == rev_string[:len(string[i:])]:\n            return string + rev_string[:i][::-1]\n\n    return string + rev_string  # Fallback if no suffix is palindrome\n\n    # Test cases\n    print(make_palindrome(''))        # ''\n    print(make_palindrome('x'))       # 'x'\n    print(make_palindrome('xyz'))     # 'xyzyx'\n    print(make_palindrome('xyx'))     # 'xyx'\n    print(make_palindrome('jerry'))    # 'jerryrrej'\n", "entry_point_expected": "make_palindrome", "has_def_line": false, "body_line_count": 15, "is_stub": false, "timestamp": "2026-02-26T23:53:20.980679"}
{"problem_id": "HumanEval/11", "attempt": 1, "sanitized_code": "    result = []\n    for bit_a, bit_b in zip(a, b):\n        result.append('1' if bit_a != bit_b else '0')\n    return ''.join(result)\n\n    # Test cases to verify logic\n    print(string_xor('111000', '101010'))  # Should return '010010'\n    print(string_xor('1', '1'))  # Should return '0'\n    print(string_xor('0101', '0000'))  # Should return '0101'\n", "entry_point_expected": "string_xor", "has_def_line": false, "body_line_count": 8, "is_stub": false, "timestamp": "2026-02-26T23:55:20.257862"}
{"problem_id": "HumanEval/12", "attempt": 1, "sanitized_code": "    if not strings:\n        return None\n    longest_str = strings[0]\n    for s in strings:\n        if len(s) > len(longest_str):\n            longest_str = s\n    return longest_str\n", "entry_point_expected": "longest", "has_def_line": false, "body_line_count": 7, "is_stub": false, "timestamp": "2026-02-26T23:56:21.333390"}
{"problem_id": "HumanEval/13", "attempt": 1, "sanitized_code": "    while b:\n        a, b = b, a % b\n    return abs(a)\n\n    # Testing the function\n    print(greatest_common_divisor(3, 5))  # Output: 1\n    print(greatest_common_divisor(25, 15))  # Output: 5\n    print(greatest_common_divisor(10, 15))  # Output: 5\n    print(greatest_common_divisor(49, 14))  # Output: 7\n    print(greatest_common_divisor(144, 60))  # Output: 12.\n", "entry_point_expected": "greatest_common_divisor", "has_def_line": false, "body_line_count": 9, "is_stub": false, "timestamp": "2026-02-26T23:58:06.242251"}
{"problem_id": "HumanEval/14", "attempt": 1, "sanitized_code": "    return [string[:i] for i in range(1, len(string) + 1)]\n", "entry_point_expected": "all_prefixes", "has_def_line": false, "body_line_count": 1, "is_stub": false, "timestamp": "2026-02-26T23:58:53.730305"}
{"problem_id": "HumanEval/15", "attempt": 1, "sanitized_code": "    return ' '.join(str(i) for i in range(n + 1))\n", "entry_point_expected": "string_sequence", "has_def_line": false, "body_line_count": 1, "is_stub": false, "timestamp": "2026-02-26T23:59:37.489264"}
{"problem_id": "HumanEval/16", "attempt": 1, "sanitized_code": "    import string\n    return len(set(string.lower()))\n\n    # Test Cases:\n    print(count_distinct_characters(''))  # 0\n    print(count_distinct_characters('abcde'))  # 5\n    print(count_distinct_characters('abcde' + 'cade' + 'CADE'))  # 5\n    print(count_distinct_characters('aaaaAAAAaaaa'))  # 1\n    print(count_distinct_characters('Jerry jERRY JeRRRY'))  # 5\n", "entry_point_expected": "count_distinct_characters", "has_def_line": false, "body_line_count": 8, "is_stub": false, "timestamp": "2026-02-27T00:00:46.922191"}
{"problem_id": "HumanEval/17", "attempt": 1, "sanitized_code": "    import string\n    # Step 1: Define Variables\n    note_mapping = {\n        'o': 4,   # whole note\n        'o|': 2,  # half note\n        '.|': 1   # quarter note\n    }\n    beats_list = []  # This will store the resulting list of beats\n\n    # Step 2: Set Up Equations\n    # We will split the input string by spaces to get the individual notes\n    notes = music_string.split()\n\n    # Step 3: Solve the Equations\n    for note in notes:\n        if note in note_mapping:  # Check if the note is in our mapping\n            beats_list.append(note_mapping[note])  # Append the corresponding beats\n\n    # Step 4: Verify Your Answer\n    # Since we cannot directly print here, we will just ensure that function returns the correct output\n    # We have covered all types of notes in this implementation\n\n    # Step 5: Final Answer\n    return beats_list\n\n    # Test Cases\n    print(parse_music('o o| .| o| o| .| .| .| .| o o'))  # Expected: [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    print(parse_music(''))  # Expected: []\n    print(parse_music('o o o o'))  # Expected: [4, 4, 4, 4]\n    print(parse_music('.| .| .| .|'))  # Expected: [1, 1, 1, 1]\n    print(parse_music('o| o| .| .| o o o o'))  # Expected: [2, 2, 1, 1, 4, 4, 4, 4]\n    print(parse_music('o| .| o| .| o o| o o|'))  # Expected: [2, 1, 2, 1, 4, 2, 4, 2]\n", "entry_point_expected": "parse_music", "has_def_line": false, "body_line_count": 27, "is_stub": false, "timestamp": "2026-02-27T00:06:07.391315"}
{"problem_id": "HumanEval/18", "attempt": 1, "sanitized_code": "    count = 0\n    sub_len = len(substring)\n\n    for i in range(len(string) - sub_len + 1):\n        if string[i:i + sub_len] == substring:\n            count += 1\n\n    return count\n\n    # Test cases to verify correctness:\n    assert how_many_times('', 'a') == 0  # Edge case: empty string\n    assert how_many_times('aaa', 'a') == 3  # Overlapping occurrences of 'a'\n    assert how_many_times('aaaa', 'aa') == 3  # Overlapping occurrences of 'aa'\n    assert how_many_times('xyxyxyx', 'x') == 4  # Non-overlapping and overlapping\n    assert how_many_times('cacacacac', 'cac') == 4  # Overlapping occurrences of 'cac'\n    assert how_many_times('john doe', 'john') == 1  # Non-overlapping 'john'\n", "entry_point_expected": "how_many_times", "has_def_line": false, "body_line_count": 13, "is_stub": false, "timestamp": "2026-02-27T00:07:08.230637"}
{"problem_id": "HumanEval/19", "attempt": 1, "sanitized_code": "    numeral_order = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n\n    if not numbers:\n        return ''\n\n    number_list = numbers.split()\n    number_list.sort(key=lambda x: numeral_order[x])\n\n    return ' '.join(number_list)\n", "entry_point_expected": "sort_numbers", "has_def_line": false, "body_line_count": 17, "is_stub": false, "timestamp": "2026-02-27T00:08:20.396249"}
{"problem_id": "HumanEval/20", "attempt": 1, "sanitized_code": "    if len(numbers) < 2:\n        return None  # Not enough elements to form a pair\n\n    numbers.sort()\n    min_diff = float('inf')\n    closest_pair = (0.0, 0.0)\n\n    for i in range(len(numbers) - 1):\n        diff = numbers[i + 1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i + 1])\n\n    return closest_pair\n\n    # Test cases\n    print(find_closest_elements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))  # (3.9, 4.0)\n    print(find_closest_elements([1.0, 2.0, 5.9, 4.0, 5.0]))       # (5.0, 5.9)\n    print(find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))  # (2.0, 2.2)\n    print(find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))  # (2.0, 2.0)\n    print(find_closest_elements([1.1, 2.2, 3.1, 4.1, 5.1]))       # (2.2, 3.1)\n    print(find_closest_elements([1.0]))                           # None\n    print(find_closest_elements([]))                              # None\n", "entry_point_expected": "find_closest_elements", "has_def_line": false, "body_line_count": 19, "is_stub": false, "timestamp": "2026-02-27T00:09:35.080827"}
{"problem_id": "HumanEval/21", "attempt": 1, "sanitized_code": "    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two elements.\")\n\n    min_val = min(numbers)\n    max_val = max(numbers)\n\n    return [(number - min_val) / (max_val - min_val) for number in numbers]\n", "entry_point_expected": "rescale_to_unit", "has_def_line": false, "body_line_count": 5, "is_stub": false, "timestamp": "2026-02-27T00:11:01.770559"}
{"problem_id": "HumanEval/22", "attempt": 1, "sanitized_code": "    return [value for value in values if isinstance(value, int)]\n", "entry_point_expected": "filter_integers", "has_def_line": false, "body_line_count": 1, "is_stub": false, "timestamp": "2026-02-27T00:11:51.375981"}
{"problem_id": "HumanEval/23", "attempt": 1, "sanitized_code": "    return len(string)\n", "entry_point_expected": "strlen", "has_def_line": false, "body_line_count": 1, "is_stub": false, "timestamp": "2026-02-27T00:12:46.052300"}
{"problem_id": "HumanEval/24", "attempt": 1, "sanitized_code": "    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # This handles the case when n is 1 or any number with no divisors larger than 1.\n", "entry_point_expected": "largest_divisor", "has_def_line": false, "body_line_count": 4, "is_stub": false, "timestamp": "2026-02-27T00:13:52.092322"}
{"problem_id": "HumanEval/25", "attempt": 1, "sanitized_code": "    if n < 2:\n        return []  # No prime factors for numbers less than 2\n\n    factors = []\n    divisor = 2\n    while n > 1:\n        while n % divisor == 0:\n            factors.append(divisor)\n            n //= divisor\n        divisor += 1\n    return factors\n\n    # Test cases to verify functionality\n    print(factorize(2))    # Expected: [2]\n    print(factorize(4))    # Expected: [2, 2]\n    print(factorize(8))    # Expected: [2, 2, 2]\n    print(factorize(57))   # Expected: [3, 19] (since 57 = 3 * 19)\n    print(factorize(171))  # Corrected Expected: [3, 3, 19] (since 171 = 3 * 3 * 19)\n", "entry_point_expected": "factorize", "has_def_line": false, "body_line_count": 16, "is_stub": false, "timestamp": "2026-02-27T00:14:59.563773"}
{"problem_id": "HumanEval/26", "attempt": 1, "sanitized_code": "    count = {}\n    for number in numbers:\n        count[number] = count.get(number, 0) + 1\n\n    result = [number for number in numbers if count[number] == 1]\n    return result\n", "entry_point_expected": "remove_duplicates", "has_def_line": false, "body_line_count": 5, "is_stub": false, "timestamp": "2026-02-27T00:15:58.142719"}
{"problem_id": "HumanEval/27", "attempt": 1, "sanitized_code": "    return ''.join(char.lower() if char.isupper() else char.upper() for char in string)\n", "entry_point_expected": "flip_case", "has_def_line": false, "body_line_count": 1, "is_stub": false, "timestamp": "2026-02-27T00:16:48.631224"}
{"problem_id": "HumanEval/28", "attempt": 1, "sanitized_code": "    result = ''.join(strings)\n    return result\n", "entry_point_expected": "concatenate", "has_def_line": false, "body_line_count": 2, "is_stub": false, "timestamp": "2026-02-27T00:17:47.740212"}
{"problem_id": "HumanEval/29", "attempt": 1, "sanitized_code": "    return [s for s in strings if s.startswith(prefix)]\n", "entry_point_expected": "filter_by_prefix", "has_def_line": false, "body_line_count": 1, "is_stub": false, "timestamp": "2026-02-27T00:18:34.374663"}
{"problem_id": "HumanEval/30", "attempt": 1, "sanitized_code": "    return [x for x in l if x > 0]\n", "entry_point_expected": "get_positive", "has_def_line": false, "body_line_count": 1, "is_stub": false, "timestamp": "2026-02-27T00:19:25.134630"}
{"problem_id": "HumanEval/31", "attempt": 1, "sanitized_code": "    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n", "entry_point_expected": "is_prime", "has_def_line": false, "body_line_count": 6, "is_stub": false, "timestamp": "2026-02-27T00:20:13.160796"}
{"problem_id": "HumanEval/33", "attempt": 1, "sanitized_code": "    # Separate values at indices divisible by 3\n    divisible_by_three = [l[i] for i in range(len(l)) if i % 3 == 0]\n    # Sort the values\n    divisible_by_three.sort()\n\n    result = l[:]\n\n    # Replace values in the result list at indices divisible by 3\n    j = 0\n    for i in range(len(result)):\n        if i % 3 == 0:\n            result[i] = divisible_by_three[j]\n            j += 1\n\n    return result\n", "entry_point_expected": "sort_third", "has_def_line": false, "body_line_count": 12, "is_stub": false, "timestamp": "2026-02-27T00:23:56.470163"}
{"problem_id": "HumanEval/34", "attempt": 1, "sanitized_code": "    return sorted(set(l))\n", "entry_point_expected": "unique", "has_def_line": false, "body_line_count": 1, "is_stub": false, "timestamp": "2026-02-27T00:25:41.081975"}
{"problem_id": "HumanEval/35", "attempt": 1, "sanitized_code": "    if not l:\n        return None  # Handle empty list case\n    maximum = l[0]\n    for element in l:\n        if element > maximum:\n            maximum = element\n    return maximum\n", "entry_point_expected": "max_element", "has_def_line": false, "body_line_count": 7, "is_stub": false, "timestamp": "2026-02-27T00:26:35.221660"}
{"problem_id": "HumanEval/36", "attempt": 1, "sanitized_code": "    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count\n", "entry_point_expected": "fizz_buzz", "has_def_line": false, "body_line_count": 5, "is_stub": false, "timestamp": "2026-02-27T00:27:51.405079"}
{"problem_id": "HumanEval/37", "attempt": 1, "sanitized_code": "    # Extract even indexed elements and sort them\n    even_indices = sorted(l[i] for i in range(0, len(l), 2))\n\n    # Reconstruct the list with sorted even indexed elements\n    result = []\n    even_index = 0\n    for i in range(len(l)):\n        if i % 2 == 0:  # even index\n            result.append(even_indices[even_index])\n            even_index += 1\n        else:  # odd index\n            result.append(l[i])\n\n    return result\n", "entry_point_expected": "sort_even", "has_def_line": false, "body_line_count": 12, "is_stub": false, "timestamp": "2026-02-27T00:28:46.909797"}
{"problem_id": "HumanEval/38", "attempt": 1, "sanitized_code": "    # split string to groups. Each of length 3, same as encoding\n    groups = [s[i:i+3] for i in range(0, len(s), 3)]\n    # recreate original strings from encoded groups\n    decoded_groups = []\n    for group in groups:\n        if len(group) == 3:\n            decoded_groups.append(group[-1] + group[:-1])  # reverse the cycle\n        else:\n            decoded_groups.append(group)  # no change for groups < 3\n    return \"\".join(decoded_groups)\n", "entry_point_expected": "decode_cyclic", "has_def_line": false, "body_line_count": 10, "is_stub": false, "timestamp": "2026-02-27T00:29:50.780780"}
{"problem_id": "HumanEval/39", "attempt": 1, "sanitized_code": "    def prime_fib(num):\n        if num <= 1:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    fibs = []\n    a, b = 0, 1\n    while len(fibs) < n:\n        a, b = b, a + b\n        if prime_fib(a):\n            fibs.append(a)\n\n    return fibs[-1]\n\n    # Verify with a test case: prime_fib(5) should return 89.\n", "entry_point_expected": "prime_fib", "has_def_line": true, "body_line_count": 15, "is_stub": false, "timestamp": "2026-02-27T00:30:52.559779"}
{"problem_id": "HumanEval/40", "attempt": 1, "sanitized_code": "    l = list(set(l))  # Remove duplicates to ensure distinct elements\n    n = len(l)\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n", "entry_point_expected": "triples_sum_to_zero", "has_def_line": false, "body_line_count": 8, "is_stub": false, "timestamp": "2026-02-27T00:32:09.061804"}
{"problem_id": "HumanEval/41", "attempt": 1, "sanitized_code": "    # Step 1: Define Variables\n    # Let n be the number of cars in each direction\n\n    # Step 2: Set Up Equations\n    # Each car moving left to right can collide with any car moving right to left\n    # Therefore, the total number of collisions is equal to the product of the number of cars in each direction\n    # This gives us the equation:\n    #\n    total_collisions = n *\n    n = n^2\n\n    # Step 3: Solve the Equations\n    total_collisions = n * n  # calculating n squared\n\n    # Step 4: Verify Your Answer\n    # We will test with provided test cases:\n    # For n = 2: 2 * 2 = 4 (correct)\n    assert car_race_collision(2) == 4\n    # For n = 3: 3 * 3 = 9 (correct)\n    assert car_race_collision(3) == 9\n    # For n = 4: 4 * 4 = 16 (correct)\n    assert car_race_collision(4) == 16\n    # For n = 8: 8 * 8 = 64 (correct)\n    assert car_race_collision(8) == 64\n    # For n = 10: 10 * 10 = 100 (correct)\n    assert car_race_collision(10) == 100\n\n    # Step 5: Final Answer\n    return total_collisions\n", "entry_point_expected": "car_race_collision", "has_def_line": false, "body_line_count": 25, "is_stub": false, "timestamp": "2026-02-27T00:35:58.543579"}
{"problem_id": "HumanEval/42", "attempt": 1, "sanitized_code": "    return [x + 1 for x in l]\n", "entry_point_expected": "incr_list", "has_def_line": false, "body_line_count": 1, "is_stub": false, "timestamp": "2026-02-27T00:39:10.239303"}
{"problem_id": "HumanEval/43", "attempt": 1, "sanitized_code": "    seen = set()\n    for number in l:\n        if -number in seen:\n            return True\n        seen.add(number)\n    return False\n", "entry_point_expected": "pairs_sum_to_zero", "has_def_line": false, "body_line_count": 6, "is_stub": false, "timestamp": "2026-02-27T00:40:09.851509"}
{"problem_id": "HumanEval/44", "attempt": 1, "sanitized_code": "    if base < 2 or base >= 10:\n        raise ValueError(\"Base must be between 2 and 9 inclusive.\")\n\n    result = ''\n    while x > 0:\n        result = str(x % base) + result\n        x //= base\n\n    return result if result else '0'\n", "entry_point_expected": "change_base", "has_def_line": false, "body_line_count": 7, "is_stub": false, "timestamp": "2026-02-27T00:41:12.499264"}
{"problem_id": "HumanEval/45", "attempt": 1, "sanitized_code": "    # Edge case handling\n    if a <= 0 or h <= 0:\n        return 0.0  # Return 0 for invalid dimensions\n\n    # Calculate area\n    area = 0.5 * a * h\n    return area\n", "entry_point_expected": "triangle_area", "has_def_line": false, "body_line_count": 6, "is_stub": false, "timestamp": "2026-02-27T00:42:24.384318"}
{"problem_id": "HumanEval/46", "attempt": 1, "sanitized_code": "    if n < 0:\n        return None  # Handle negative cases if needed\n\n\n    # Initialize the base cases\n    fibs = [0, 0, 2, 0]  # fib4(0), fib4(1), fib4(2), fib4(3)\n\n    # If n is within the base cases, return directly\n    if n < len(fibs):\n        return fibs[n]\n\n    # Compute fib4 values iteratively for n >= 4\n    for i in range(4, n + 1):\n        next_fib = fibs[i-1] + fibs[i-2] + fibs[i-3] + fibs[i-4]\n        fibs.append(next_fib)\n\n    return fibs[n]\n", "entry_point_expected": "fib4", "has_def_line": false, "body_line_count": 12, "is_stub": false, "timestamp": "2026-02-27T00:43:33.044199"}
{"problem_id": "HumanEval/47", "attempt": 1, "sanitized_code": "    n = len(l)\n    if n == 0:\n        return None\n    l.sort()\n    mid = n // 2\n    if n % 2 == 0:\n        return (l[mid - 1] + l[mid]) / 2\n    else:\n        return l[mid]\n", "entry_point_expected": "median", "has_def_line": false, "body_line_count": 9, "is_stub": false, "timestamp": "2026-02-27T00:44:39.352087"}
{"problem_id": "HumanEval/48", "attempt": 1, "sanitized_code": "    return text == text[::-1]\n", "entry_point_expected": "is_palindrome", "has_def_line": false, "body_line_count": 1, "is_stub": false, "timestamp": "2026-02-27T00:45:38.841965"}
{"problem_id": "HumanEval/49", "attempt": 1, "sanitized_code": "    return pow(2, n, p)\n", "entry_point_expected": "modp", "has_def_line": false, "body_line_count": 1, "is_stub": false, "timestamp": "2026-02-27T00:46:37.946411"}

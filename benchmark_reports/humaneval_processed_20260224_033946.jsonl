{"problem_id": "HumanEval/0", "attempt": 1, "sanitized_code": "    # Handle edge cases\n    if len(numbers) < 2:\n        return False\n\n    # Compare all pairs\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n\n    return False\n", "entry_point_expected": "has_close_elements", "has_def_line": false, "body_line_count": 9, "is_stub": false, "timestamp": "2026-02-24T03:41:06.401468"}
{"problem_id": "HumanEval/1", "attempt": 1, "sanitized_code": "    import string\n    paren_string = paren_string.replace(\" \", \"\")  # Remove spaces\n    groups = []\n    balance = 0\n    current_group = []\n\n    for char in paren_string:\n        if char == '(':\n            if balance == 0 and current_group:\n                groups.append(''.join(current_group))  # Save the completed group\n                current_group = []\n            current_group.append(char)\n            balance += 1\n        elif char == ')':\n            current_group.append(char)\n            balance -= 1\n            if balance == 0:\n                groups.append(''.join(current_group))  # Save the completed group\n                current_group = []\n\n    return groups\n", "entry_point_expected": "separate_paren_groups", "has_def_line": false, "body_line_count": 19, "is_stub": false, "timestamp": "2026-02-24T03:42:29.804837"}
{"problem_id": "HumanEval/2", "attempt": 1, "sanitized_code": "    return number - int(number)\n", "entry_point_expected": "truncate_number", "has_def_line": false, "body_line_count": 1, "is_stub": false, "timestamp": "2026-02-24T03:43:23.347559"}
{"problem_id": "HumanEval/3", "attempt": 1, "sanitized_code": "    balance = 0\n    for operation in operations:\n        balance += operation\n        if balance < 0:\n            return True\n    return False\n", "entry_point_expected": "below_zero", "has_def_line": false, "body_line_count": 6, "is_stub": false, "timestamp": "2026-02-24T03:44:16.556087"}
{"problem_id": "HumanEval/4", "attempt": 1, "sanitized_code": "    if not numbers:\n        return 0.0\n\n    mean_value = sum(numbers) / len(numbers)\n    deviations = [abs(x - mean_value) for x in numbers]\n    mad = sum(deviations) / len(deviations)\n\n    return mad\n", "entry_point_expected": "mean_absolute_deviation", "has_def_line": false, "body_line_count": 6, "is_stub": false, "timestamp": "2026-02-24T03:45:25.082858"}
{"problem_id": "HumanEval/5", "attempt": 1, "sanitized_code": "    result = []\n    for i in range(len(numbers)):\n        result.append(numbers[i])\n        if i < len(numbers) - 1:\n            result.append(delimeter)\n    return result\n", "entry_point_expected": "intersperse", "has_def_line": false, "body_line_count": 6, "is_stub": false, "timestamp": "2026-02-24T03:46:43.622060"}
{"problem_id": "HumanEval/6", "attempt": 1, "sanitized_code": "    import string\n    results = []\n    for group in paren_string.split():\n        max_depth = 0\n        current_depth = 0\n        for char in group:\n            if char == '(':\n                current_depth += 1\n                max_depth = max(max_depth, current_depth)\n            elif char == ')':\n                current_depth -= 1\n        results.append(max_depth)\n    return results\n", "entry_point_expected": "parse_nested_parens", "has_def_line": false, "body_line_count": 13, "is_stub": false, "timestamp": "2026-02-24T03:47:48.955535"}
{"problem_id": "HumanEval/7", "attempt": 1, "sanitized_code": "    return [s for s in strings if substring in s]\n", "entry_point_expected": "filter_by_substring", "has_def_line": false, "body_line_count": 1, "is_stub": false, "timestamp": "2026-02-24T03:48:44.208111"}
{"problem_id": "HumanEval/8", "attempt": 1, "sanitized_code": "    if not numbers:\n        return (0, 1)\n\n    total_sum = sum(numbers)\n    total_product = 1\n    for num in numbers:\n        total_product *= num\n\n    return (total_sum, total_product)\n", "entry_point_expected": "sum_product", "has_def_line": false, "body_line_count": 7, "is_stub": false, "timestamp": "2026-02-24T03:49:48.763241"}
{"problem_id": "HumanEval/9", "attempt": 1, "sanitized_code": "    if not numbers:\n        return []\n\n    max_so_far = numbers[0]\n    result = [max_so_far]\n\n    for num in numbers[1:]:\n        if num > max_so_far:\n            max_so_far = num\n        result.append(max_so_far)\n\n    return result\n", "entry_point_expected": "rolling_max", "has_def_line": false, "body_line_count": 9, "is_stub": false, "timestamp": "2026-02-24T03:50:50.817802"}
{"problem_id": "HumanEval/10", "attempt": 1, "sanitized_code": "    if not string:\n        return ''\n\n    for i in range(len(string)):\n        if is_palindrome(string[i:]):\n            return string + string[:i][::-1]\n\n    return string + string[::-1]  # Fallback in case no palindromic suffix found\n", "entry_point_expected": "make_palindrome", "has_def_line": false, "body_line_count": 6, "is_stub": false, "timestamp": "2026-02-24T03:52:00.352831"}
{"problem_id": "HumanEval/11", "attempt": 1, "sanitized_code": "    result = []\n    for bit_a, bit_b in zip(a, b):\n        result.append('1' if bit_a != bit_b else '0')\n    return ''.join(result)\n", "entry_point_expected": "string_xor", "has_def_line": false, "body_line_count": 4, "is_stub": false, "timestamp": "2026-02-24T03:53:00.751505"}
{"problem_id": "HumanEval/12", "attempt": 1, "sanitized_code": "    if not strings:\n        return None\n    longest_str = strings[0]\n    for s in strings:\n        if len(s) > len(longest_str):\n            longest_str = s\n    return longest_str\n", "entry_point_expected": "longest", "has_def_line": false, "body_line_count": 7, "is_stub": false, "timestamp": "2026-02-24T03:53:51.823113"}
{"problem_id": "HumanEval/13", "attempt": 1, "sanitized_code": "    while b:\n        a, b = b, a % b\n    return abs(a)\n\n    # Test cases\n    print(greatest_common_divisor(3, 7))    # should return 1\n    print(greatest_common_divisor(10, 15))  # should return 5\n    print(greatest_common_divisor(49, 14))  # should return 7\n    print(greatest_common_divisor(144, 60)) # should return 12.\n", "entry_point_expected": "greatest_common_divisor", "has_def_line": false, "body_line_count": 8, "is_stub": false, "timestamp": "2026-02-24T03:55:06.021538"}
{"problem_id": "HumanEval/14", "attempt": 1, "sanitized_code": "    return [string[:i] for i in range(1, len(string) + 1)]\n", "entry_point_expected": "all_prefixes", "has_def_line": false, "body_line_count": 1, "is_stub": false, "timestamp": "2026-02-24T03:55:57.956557"}
{"problem_id": "HumanEval/15", "attempt": 1, "sanitized_code": "    return ' '.join(str(i) for i in range(n + 1))\n", "entry_point_expected": "string_sequence", "has_def_line": false, "body_line_count": 1, "is_stub": false, "timestamp": "2026-02-24T03:57:02.859195"}
{"problem_id": "HumanEval/16", "attempt": 1, "sanitized_code": "    import string\n    return len(set(string.lower()))\n", "entry_point_expected": "count_distinct_characters", "has_def_line": false, "body_line_count": 2, "is_stub": false, "timestamp": "2026-02-24T03:57:59.487110"}
{"problem_id": "HumanEval/17", "attempt": 1, "sanitized_code": "    import string\n    # Step 1: Define Variables\n    note_durations = {\n        'o': 4,   # whole note, lasts four beats\n        'o|': 2,  # half note, lasts two beats\n        '.|': 1    # quarter note, lasts one beat\n    }\n\n    # Step 2: Process the input string\n    notes = music_string.split()  # Split the string by spaces\n    result = []                   # Initialize an empty list to hold the result\n\n    # Step 3: Convert notes to their corresponding beat durations\n    for note in notes:\n        if note in note_durations:  # Check if the note is in our dictionary\n            result.append(note_durations[note])  # Append the duration to the result list\n        elif note == 'o':  # Check for whole note (without additional characters)\n            result.append(note_durations[note])  # Append the whole note duration\n\n    # Step 4: Return the final computed list of durations\n    return result\n\n    # Trace through the test cases to verify correctness\n    # Test case: 'o o| .| o| o| .| .| .| .| o o'\n    # Expected output: [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    print(parse_music('o o| .| o| o| .| .| .| .| o o'))  # should output [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n", "entry_point_expected": "parse_music", "has_def_line": false, "body_line_count": 22, "is_stub": false, "timestamp": "2026-02-24T04:04:01.824302"}
{"problem_id": "HumanEval/18", "attempt": 1, "sanitized_code": "    import string\n    if not substring:  # If the substring is empty\n        return 0\n\n    count = 0\n    start = 0\n\n    while True:\n        start = string.find(substring, start)  # Find the starting index of the substring\n        if start == -1:  # If no more occurrences are found\n            break\n        count += 1  # Increment count for each found occurrence\n        start += 1  # Move to the next character for overlapping\n\n    return count\n", "entry_point_expected": "how_many_times", "has_def_line": false, "body_line_count": 12, "is_stub": false, "timestamp": "2026-02-24T04:05:07.462555"}
{"problem_id": "HumanEval/19", "attempt": 1, "sanitized_code": "    num_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n\n    # Split the input string into words\n    words = numbers.split()\n\n    # Sort the words based on their corresponding numeric values\n    sorted_words = sorted(words,\n    key=lambda x: num_map[x])\n\n    # Join the sorted list back into a string\n    return ' '.join(sorted_words)\n", "entry_point_expected": "sort_numbers", "has_def_line": false, "body_line_count": 19, "is_stub": false, "timestamp": "2026-02-24T04:14:59.021679"}
{"problem_id": "HumanEval/20", "attempt": 1, "sanitized_code": "    numbers.sort()\n    closest_pair = (numbers[0], numbers[1])\n    min_diff = abs(numbers[0] - numbers[1])\n\n    for i in range(1, len(numbers)):\n        diff = abs(numbers[i] - numbers[i - 1])\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i - 1], numbers[i])\n\n    return closest_pair\n", "entry_point_expected": "find_closest_elements", "has_def_line": false, "body_line_count": 9, "is_stub": false, "timestamp": "2026-02-24T04:16:28.122158"}
{"problem_id": "HumanEval/21", "attempt": 1, "sanitized_code": "    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two elements.\")\n\n    min_value = min(numbers)\n    max_value = max(numbers)\n\n    if min_value == max_value:\n        return [0.0] * len(numbers)\n\n    return [(number - min_value) / (max_value - min_value) for number in numbers]\n\n    # Verifying with test cases\n    print(rescale_to_unit([2.0, 49.9]))  # \u2192 [0.0, 1.0]\n    print(rescale_to_unit([100.0, 49.9]))  # \u2192 [1.0, 0.0]\n    print(rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0]))  # \u2192 [0.0, 0.25, 0.5, 0.75, 1.0]\n    print(rescale_to_unit([2.0, 1.0, 5.0, 3.0, 4.0]))  # \u2192 [0.25, 0.0, 1.0, 0.5, 0.75]\n    print(rescale_to_unit([12.0, 11.0, 15.0, 13.0, 14.0]))  # \u2192 [0.25, 0.0, 1.0, 0.5, 0.75]\n", "entry_point_expected": "rescale_to_unit", "has_def_line": false, "body_line_count": 13, "is_stub": false, "timestamp": "2026-02-24T04:17:49.940679"}
{"problem_id": "HumanEval/22", "attempt": 1, "sanitized_code": "    return [value for value in values if isinstance(value, int)]\n", "entry_point_expected": "filter_integers", "has_def_line": false, "body_line_count": 1, "is_stub": false, "timestamp": "2026-02-24T04:18:44.293538"}
{"problem_id": "HumanEval/23", "attempt": 1, "sanitized_code": "    return len(string)\n", "entry_point_expected": "strlen", "has_def_line": false, "body_line_count": 1, "is_stub": false, "timestamp": "2026-02-24T04:19:32.198909"}
{"problem_id": "HumanEval/24", "attempt": 1, "sanitized_code": "    if n <= 1:\n        raise ValueError(\"n must be greater than 1\")\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    This revised version raises an error when `n` is less than or equal to 1, which is a more appropriate way to indicate input constraints rather than returning `None`. The docstring is expanded for clarity\n\n    My confidence in this improved response is 9/10.\n", "entry_point_expected": "largest_divisor", "has_def_line": false, "body_line_count": 7, "is_stub": false, "timestamp": "2026-02-24T04:20:32.983933"}
